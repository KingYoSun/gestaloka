# システムパターン - ゲスタロカ (Gestaloka)

**最終更新日:** 2025/06/14  
**ドキュメントバージョン:** 1.0

## 概要

本ドキュメントは、ゲスタロカのアーキテクチャパターン、データフロー、および設計原則を定義します。すべての実装はこれらのパターンに従う必要があります。

## アーキテクチャ原則

### 1. 関心の分離 (Separation of Concerns)
- **認証**: KeyCloakに完全委譲
- **ビジネスロジック**: FastAPIアプリケーション
- **リアルタイム通信**: WebSocket専用レイヤー
- **非同期処理**: Celeryワーカー
- **データ永続化**: PostgreSQL（構造化）+ Neo4j（関係性）

### 2. イベント駆動アーキテクチャ
- すべてのプレイヤー行動はイベントとして記録
- イベントソーシングによる状態再構築
- 非同期イベントハンドラーによる拡張性

### 3. AI協調パターン
- 各AIエージェントは単一責任原則に従う
- AIエージェント間の通信はデータベース経由
- 明確なインターフェースによる疎結合

## データフロー図

### 1. 認証フロー

認証フローは以下の手順で実行されます：
1. クライアントからKeyCloakへログインリクエスト
2. KeyCloakでの認証情報検証
3. JWTトークンの返却
4. JWTを使用したAPIリクエスト
5. APIサーバーでのJWT検証
6. データベースからユーザー情報取得/作成
7. レスポンスの返却

### 2. ゲームプレイフロー

ゲームプレイは複数のレイヤーを通じて処理されます：
- **クライアント層**: React UIとWebSocketクライアント
- **API層**: FastAPIサーバー、Socket.IOサーバー、LangChainマネージャー
- **AI層**: 6つの専門AI（脚本家、状態管理、NPC管理、歴史家、世界の意識、混沌）
- **データ層**: PostgreSQL、Neo4j、Redis
- **外部サービス**: Gemini 2.5 Pro

### 3. ログ生成フロー

ログ生成の状態遷移：
- プレイヤー行動 → イベント記録 → 重要度判定
- ログの欠片生成 → インベントリ保存 → ログ編纂
- 欠片の組み合わせ → ログ検証 → 完成ログ
- ログ契約 → 他世界へ配置

## データモデルパターン

### 1. エンティティ分離

```
PostgreSQL (構造化データ)
├── users (KeyCloak IDと紐付け)
├── characters (Player, LogNPC, NPC)
├── skills
├── items
├── events (イベントログ)
└── log_fragments

Neo4j (関係性データ)
├── Player nodes
├── LogNPC nodes
├── NPC nodes
├── Location nodes
└── Relationships (INTERACTED_WITH, LOCATED_IN, etc.)
```

### 2. イベントソーシング

**イベント構造の設計原則:**
- 一意のイベントIDとタイムスタンプによる追跡可能性
- プレイヤーIDによる行動主体の明確化
- イベントタイプによる分類と処理の最適化
- ペイロードによる柔軟なデータ格納
- 状態変更の明示的な記録による監査証跡

### 3. ログフラグメント構造

**ログフラグメントの主要要素:**
- **識別情報**: 一意のIDとプレイヤー紐付け
- **時系列データ**: タイムスタンプによる時系列管理
- **意味的タグ**: キーワードによる内容の分類
- **感情的指標**: -1.0から1.0の範囲での感情値
- **希少度**: 一般的なものから希少なものまでの分類
- **物語的要素**: プレイヤー行動の物語的な記述
- **ソース追跡**: 元となったイベントIDのリスト

## API設計パターン

### 1. RESTful + WebSocket ハイブリッド

```
RESTful API (HTTP)
├── 認証・認可
├── キャラクター作成・管理
├── 静的データ取得
└── 非リアルタイム操作

WebSocket (Socket.IO)
├── ゲームプレイ中の行動
├── リアルタイム物語生成
├── 戦闘システム
└── プレイヤー間相互作用
```

### 2. フロントエンドルーティングパターン

**TanStack Router実装方針:**
- **ファイルベースルーティング**: 直感的なディレクトリ構造によるルート定義
- **型安全性**: コンパイル時の型チェックによるナビゲーションエラー防止
- **認証統合**: ProtectedRouteコンポーネントによる統一的なアクセス制御
- **レイアウト継承**: 共通レイアウトの効率的な再利用

**主要ルート構成:**
- ルートレイアウト（__root.tsx）: アプリケーション全体のプロバイダー設定
- 認証画面（login.tsx）: ログイン・登録フロー
- ダッシュボード（dashboard.tsx）: ユーザーホーム画面
- キャラクター管理（character.*.tsx）: 作成・編集・詳細表示
- ゲームセッション（game.$sessionId.tsx）: 動的ルートによるセッション管理
- ログ管理（logs.tsx）: ログフラグメントと完成ログの管理
- 設定画面（settings.tsx）: ユーザー設定とプリファレンス

### 3. API レスポンス構造

**統一レスポンス形式の設計原則:**
- **成功/失敗の明示**: `success`フラグによる結果の明確化
- **データペイロード**: 成功時のデータを`data`フィールドに格納
- **エラー情報**: 失敗時の詳細を`error`フィールドで提供
- **メタデータ**: ページネーション、処理時間、バージョン情報などの付加情報

## AI協調パターン

### 1. AI協調動作プロトコル

AI協調システムは以下のレイヤーで構成されます：
- **プレイヤー層**: プレイヤーアクションの受付
- **コーディネーター層**: CoordinatorAI、タスクリスト生成、共有コンテキスト、イベント連鎖
- **AIエージェント層**: 6つの専門AI
- **データ層**: レスポンスキャッシュとデータベース

並列実行と順次実行の最適化により、効率的なAI処理を実現します。

### 2. タスク最適化フロー

タスク最適化の処理順序：
1. プレイヤーからのアクション実行要求
2. タスクリスト生成とアクション分類
3. 最適化されたタスクリストの作成
4. 進捗通知付きのタスク実行（0%〜100%）
5. レスポンス統合と最終応答

### 3. イベント連鎖システム

イベント連鎖の状態遷移：
- イベント発行 → 優先度キューへ追加 → イベント処理
- ハンドラー実行 → 二次イベント生成/状態更新
- 連鎖深度チェック（最大3段階）
- 処理完了または連鎖終了

### 4. AI責任分離（協調動作版）

| AI | 入力 | 処理 | 出力 | 協調役割 |
|----|------|------|------|----------|
| 脚本家AI | イベント、コンテキスト | 物語生成 | テキスト、選択肢 | 常に必要 |
| 状態管理AI | アクション、ルール | 状態計算 | 更新されたステート | 行動判定時必要 |
| NPC管理AI | 世界の要求 | キャラクター生成 | NPCデータ | NPC関連時のみ |
| 歴史家AI | 全イベント | 歴史編纂 | 構造化された歴史 | 重要イベント時 |
| 世界の意識AI | 集合的行動 | マクロイベント判定 | 世界イベント | 場面転換時 |
| 混沌AI | ランダムシード | 異常イベント生成 | カオスイベント | 確率的に発生 |

### 5. 共有コンテキスト構造

**SharedContextの主要コンポーネント:**

1. **セッション情報**
   - セッションIDによる一意の識別
   - ターン番号による進行状況の追跡

2. **世界状態**
   - 現在の世界の状態を表現
   - 天候、時刻、アクティブなイベントの管理

3. **キャラクター状態**
   - プレイヤーの現在の状態
   - アクティブなNPCとその状態の管理

4. **履歴情報**
   - 最近の行動（最新10件）の保持
   - 最近のイベント（最新20件）の記録
   - 重要な決定の永続的な記録

5. **AI決定履歴**
   - 各AIエージェントの決定履歴
   - デバッグとAI改善のための情報

6. **一時効果**
   - アクティブな一時的効果のリスト
   - 環境による修正値の管理

## エラーハンドリングパターン

### 1. 階層的エラー処理

**エラーカテゴリーの階層構造:**
- **GameError**: 基底エラークラス - すべてのゲーム関連エラーの親クラス
- **ValidationError**: 入力検証エラー - ユーザー入力の妥当性チェック失敗
- **StateError**: ゲーム状態エラー - 不正な状態遷移や状態の不整合
- **AIError**: AI処理エラー - LLM応答エラーやAI協調の失敗

### 2. グレースフルデグラデーション

- LLM応答失敗時: 事前定義済みの応答を使用
- データベース接続失敗時: キャッシュから応答
- AI協調失敗時: 単一AIでの処理継続

## パフォーマンスパターン

### 1. キャッシング戦略

```
Redis キャッシュ層
├── セッションデータ (TTL: 1時間)
├── 頻繁にアクセスされるキャラクターデータ (TTL: 10分)
├── LLM応答キャッシュ (TTL: 5分)
└── 静的ゲームデータ (TTL: 1日)
```

### 2. 非同期処理

**Celeryタスクの実装パターン:**
- **ログ生成処理**: イベントIDを受け取り、バックグラウンドでログフラグメントを生成
- **世界統計更新**: 定期的に世界全体の統計情報を集計・更新
- **NPC生成**: 完成したログからNPCエンティティを非同期で生成
- **イベント連鎖処理**: 複雑なイベント連鎖をキューで管理

## セキュリティパターン

### 1. 入力検証

**Pydanticによる厳密な型検証:**
- **型安全性**: すべての入力データの型を厳密にチェック
- **バリデーション**: 許可されたアクションタイプのみを受け入れ
- **エラーメッセージ**: 明確で具体的なエラー情報の提供
- **自動ドキュメント**: OpenAPIスキーマの自動生成

### 2. プロンプトインジェクション対策

**LLMプロンプトのセキュリティ対策:**
- **特殊文字のエスケープ**: SQLインジェクション類似の攻撃を防止
- **プロンプト区切り文字の除去**: システムプロンプトへの干渉を防止
- **長さ制限の適用**: 過度に長い入力による攻撃を防止
- **コンテキスト分離**: ユーザー入力とシステムプロンプトの明確な分離

## テスト戦略パターン

### 1. テストピラミッド

```
単体テスト (70%)
├── ビジネスロジック
├── データ変換
└── ユーティリティ関数

統合テスト (20%)
├── API エンドポイント
├── データベース操作
└── AI連携

E2Eテスト (10%)
├── 主要なユーザーフロー
└── クリティカルパス
```

### 2. モックパターン

**テスト用モックの実装方針:**
- **AI応答のモック**: 事前定義された応答による確定的なテスト
- **データベースモック**: インメモリDBによる高速テスト
- **外部サービスモック**: WebSocketやRedisの動作シミュレーション
- **時間依存モック**: 時刻に依存する処理の制御可能なテスト

## デプロイメントパターン

### 1. コンテナ構成

**Docker Composeサービス構成:**
- **frontend**: React/Viteアプリケーション（本番ビルド）
- **backend**: FastAPIサーバー（依存: postgres, neo4j, redis）
- **worker**: Celeryワーカー（非同期タスク処理）
- **beat**: Celeryビート（定期タスク管理）
- **flower**: Celery監視ツール
- **postgres**: リレーショナルデータベース
- **neo4j**: グラフデータベース
- **redis**: キャッシュ・メッセージブローカー
- **keycloak**: 認証サーバー

### 2. 環境別設定

```
開発環境
├── ローカルDB
├── モックLLM
└── デバッグモード有効

ステージング環境
├── 隔離されたDB
├── 実LLM（レート制限付き）
└── 本番同等の構成

本番環境
├── 高可用性DB
├── 実LLM（フルアクセス）
└── 監視・アラート有効
```

## ゲームセッション管理パターン

### 1. セッション状態管理フロー

セッション管理の処理順序：
1. プレイヤーからのゲーム開始要求
2. フロントエンドからAPIへのPOSTリクエスト
3. GameSessionServiceでのセッション作成
4. 既存セッションの非アクティブ化
5. 新規セッションの作成
6. Zustandストアへの状態保存
7. ゲーム画面の表示

### 2. アクション実行パターン

アクション実行の状態遷移：
- セッション開始 → 入力待機
- アクション入力 → 検証処理
- 検証成功 → AI処理またはモック応答
- セッション更新 → 再度入力待機
- セッション終了要求 → 終了

### 3. 状態管理統合パターン

**React Query + Zustand 統合戦略:**
- **サーバー状態**: React Queryによるキャッシュ管理と自動再取得
- **クライアント状態**: Zustandによるローカル状態の効率的な管理
- **同期メカニズム**: useEffectによるサーバー・クライアント状態の同期
- **選択的購読**: 必要なデータのみを購読してレンダリング最適化

### 4. エラーハンドリングパターン

**サービス層エラーハンドリングの実装方針:**

1. **事前検証**
   - キャラクター所有権の確認
   - リソースの存在確認
   - 権限チェック

2. **段階的処理**
   - 既存セッションの適切な終了処理
   - 新規リソースの作成
   - レスポンスの構築

3. **具体的なエラーハンドリング**
   - **404 Not Found**: リソースが見つからない場合
   - **403 Forbidden**: 権限がない場合
   - **500 Internal Server Error**: 予期しないエラー

4. **ロギング戦略**
   - エラーレベルに応じた適切なログ出力
   - デバッグ情報の記録
   - ユーザーへの適切なメッセージ提供

### 5. UI状態管理パターン

**Zustandによる状態管理の設計:**

1. **状態構造**
   - **activeSession**: 現在アクティブなゲームセッション
   - **messageHistory**: セッションIDごとのメッセージ履歴
   - **currentChoices**: 現在提示されている選択肢
   - **isExecutingAction**: アクション実行中フラグ

2. **永続化戦略**
   - **選択的永続化**: 重要なデータのみlocalStorageに保存
   - **セッション復元**: ページリロード時の状態復元
   - **メモリ効率**: 不要なデータの自動クリーンアップ

3. **パフォーマンス最適化**
   - **選択的レンダリング**: 必要なコンポーネントのみ再レンダリング
   - **メモ化**: 計算コストの高い処理のキャッシュ
   - **バッチ更新**: 複数の状態更新をまとめて処理

## まとめ

これらのパターンは、ゲスタロカの開発において一貫性と品質を保つための指針です。新機能の実装時は必ずこれらのパターンを参照し、逸脱する場合は明確な理由とドキュメント化が必要です。

**ゲームセッション機能実装により確立されたパターン:**
- サービス層によるビジネスロジック分離
- React Query + Zustand統合による状態管理
- 型安全なAPIクライアント設計（snake_case ↔ camelCase変換）
- 段階的UI実装（基本機能優先のアプローチ）