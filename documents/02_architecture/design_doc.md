# ログバース (Logverse) - ゲームデザインドキュメント

**ドキュメントバージョン:** 2.5
**最終更新日:** 2025/06/13
**作成者:** Gemini

## 1. 概要 (Overview)

### 1.1. はじめに

本ドキュメントは、マルチプレイ・テキストMMO「ログバース (Logverse)」の設計仕様を定義するものです。LLM（大規模言語モデル）とグラフデータベース、リレーショナルデータベースを組み合わせ、プレイヤーの行動履歴（ログ）が他のプレイヤーの世界に影響を与える、これまでにないゲーム体験の創出を目的とします。

### 1.2. コンセプト

**「あなたの"ログ"が、新たな物語を紡ぐ」**

プレイヤーはLLMとの対話を通じて自由な物語を創造します。その行動履歴は「ログ」として記録・蓄積され、他のプレイヤーの世界にNPCとして登場します。プレイヤーは過去の自分自身である「ログ」を分岐・育成し、多世界解釈的な物語を体験できます。

### 1.3. 対象ユーザー

* テキストベースのRPGやアドベンチャーゲームのファン
* TRPG（テーブルトークRPG）のような自由度の高い物語体験を求めるプレイヤー
* 他のプレイヤーと緩やかに繋がり、独自の世界を創造することに喜びを感じるプレイヤー

### 1.4. プロジェクト目標

* **MVP（Minimum Viable Product）の開発:** コアとなるゲームサイクル（キャラクター作成 → プレイ → ログ生成 → NPC化）を実装し、早期にユーザーからのフィードバックを得る。
* **コミュニティ形成:** プレイヤーが自身の「ログ」を通じて交流し、物語を共有できるプラットフォームを構築する。
* **技術的検証:** LLM、グラフDB、RDBを組み合わせた、動的でスケーラブルなゲームシステムの実現可能性を証明する。

## 2. ゲームデザイン (Game Design)

### 2.1. ゲームのコアサイクル

1.  **キャラクター作成:** プレイヤーは名前、外見、性格、初期スキルなどを設定し、ゲームを開始します。
2.  **物語の進行:** プレイヤーは、後述の「GM AI評議会」によって生成される状況に対し、自由記述やコマンドで行動を入力します。LLMは入力内容を解釈し、物語をリアルタイムに生成・進行させます。
3.  **「ログ」の記録:** プレイヤーの一連の行動、発言、重要な出来事はすべてタイムスタンプ付きでデータベースに記録されます。
4.  **「ログ」のNPC化:**
    * 他プレイヤーの世界で、関連性の高い「ログ」がNPCとして自動的に登場します。
    * プレイヤーは自身の「ログ」を任意のタイミングで「分岐」させ、独立したNPCとして育成・管理できます。
5.  **交流と世界の変容:** プレイヤーは、自身のキャラクターだけでなく、他のプレイヤーが生み出した無数の「ログ」NPCや、GM AIによって生み出された永続的なNPCと交流することで、常に変化し続ける世界を冒険します。

### 2.2. ゲームマスターAI (GM AI) 評議会

ログバースの世界は、以下の専門的な役割を持つAIエージェント群によって動的に管理・運営されます。

* **脚本家AI (Dramatist):**
    * **役割:** メインのストーリーテラー。プレイヤーの行動に応じて物語を進行させ、魅力的なテキストや状況を描写します。
    * **機能:** 基本的なストーリーテリング、プレイヤーに提示する選択肢の発行、個人向けシナリオ（クエスト）の生成。
* **歴史家AI (Historian):**
    * **役割:** 世界の記録係。全てのエンティティの行動履歴から「世界の公式な歴史」や「噂」を編纂します。
    * **機能:** 重要な出来事を構造化データとして記録し、ゲーム内の書物やNPCの会話として世界に反映させます。
* **世界の意識AI (The World):**
    * **役割:** マクロな視点を持つ世界の調停者。プレイヤーコミュニティ全体の行動の総和が世界に与える影響を観測し、世界規模のイベントを発生させます。
    * **機能:** 資源の枯渇や地域の平和度などに応じて、環境変動やポジティブなイベントを発生させます。
* **混沌AI (The Anomaly):**
    * **役割:** 予測不能性の源。世界の理（ルール）から外れた「理不尽」なイベントをランダムに発生させ、プレイヤーに驚きと挑戦を提供します。
    * **機能:** 超常現象の発生、「ログの暴走」イベントのトリガーと性質の決定。
* **NPC管理AI (NPC Manager):**
    * **役割:** 世界に必要な、プレイヤーやログではない永続的な登場人物を創造・管理する創世主。
    * **機能:** 他のGM AI（脚本家、世界の意識など）からの要求に基づき、物語の文脈に合ったNPCのキャラクターシート（背景、性格、能力）を生成・更新する。一度生成されたNPCは、死亡もしくは消失と判定されるまで世界に存在し続けます。
* **状態管理AI (State Manager):**
    * **役割:** 全エンティティの状態を管理するルールエンジン。データベースの情報に基づき状態を計算・判定します。
    * **機能:** パラメータ、スキル、称号、装備、所持品などの状態を記録・管理し、行動結果を判定してDBを更新します。他のGM AIへの正確なデータ提供も担います。

### 2.3. UI/UXデザイン

* **インターフェース:** テキストベースのUIを基本とします。チャットウィンドウ形式で物語が進行し、コマンド入力や選択肢で操作します。
* **ビジュアル:** シーンの挿絵やキャラクターの立ち絵として、画像生成AIによるビジュアルを補助的に導入し、没入感を高めます。

## 3. テクニカルデザイン (Technical Design)

### 3.1. システムアーキテクチャ

認証基盤としてKeyCloakを導入し、アプリケーションサーバーから認証・認可の責務を分離します。クライアントはKeyCloakで認証後、取得したJWTを用いてAPIにアクセスします。

```mermaid
graph TD;
    subgraph "User Interaction"
        client[Client<br/>(Web Browser)]
    end

    subgraph "Authentication"
        keycloak[KeyCloak]
    end

    subgraph "Application Backend"
        app[Application Server<br/>(FastAPI, incl. GM AI)]
        workers[Backend Workers<br/>(Celery)]
        broker[Message Broker<br/>(Redis)]
        websocket[Realtime Server<br/>(Socket.IO)]
    end

    subgraph "External Services"
        llm[LLM API<br/>(Gemini 2.5 Pro)]
    end

    subgraph "Data Stores"
        rdb[Relational Database<br/>(PostgreSQL)]
        graphdb[Graph Database<br/>(Neo4j)]
    end

    %% Connections
    client --> |1. Authenticates| keycloak
    keycloak --> |2. Returns JWT| client
    client --> |3. API Request with JWT| app
    client <--> |Realtime Comm.| websocket

    app <--> websocket
    app --> |4. Reads/Writes| rdb
    app --> |4. Reads/Writes| graphdb
    app --> |5. Generates Narrative| llm
    app --> |6. Enqueues Job| broker

    broker --> |7. Delivers Job| workers
    workers --> |8. Processes & Updates| rdb
    workers --> |8. Processes & Updates| graphdb
```

### 3.2. 技術選定

| カテゴリ | 技術 | 理由 |
| --- | --- | --- |
| 認証基盤 | KeyCloak | 堅牢な認証・認可機能を自前で実装するコストを削減し、業界標準のプロトコル（OAuth 2.0, OpenID Connect）に対応するため。ユーザー管理、ソーシャルログイン、多要素認証などをアプリケーションから早期に分離でき、将来的なユーザーデータ移行の手間も発生しない。 |
| フロントエンド | TypeScript, React, Vite, shadcn/ui, zod, zustand, TanStack Query, React Hook Form, Vitest, Motion, ESLint, Prettier | モダンで堅牢な開発体験を提供する技術スタック。静的型付け、高速なビルド、効率的な状態管理とデータフェッチ、高品質なUIコンポーネント、テスト、コード品質維持ツールを網羅。 |
| バックエンド | Python, FastAPI, Pydantic-Settings, Pytest, Ruff | LangChainとの親和性が高く、型安全で高品質なコードを効率的に開発可能。設定管理やテスト、コード品質維持ツールを網羅。 |
| データベース | PostgreSQL (リレーショナル), Neo4j (グラフ) | 役割の分離（ポリグロットパーシステンス）。PostgreSQLは構造化データとトランザクションの信頼性を、Neo4jは複雑な関係性の表現と高速なクエリを担う。 |
| データベース連携 | SQLModel, neomodel | 型安全なコードで効率的にデータベースを操作するため。SQLModelはFastAPIとの親和性が高く、neomodelはグラフDBを直感的に扱える。 |
| LLM | Gemini 2.5 Pro | 最新の高性能モデルであり、長文の文脈理解能力に優れているため、一貫性のある物語生成に寄与する。 |
| LLM連携 | LangChain | プロンプト管理、メモリ（対話履歴）、外部データ連携などを抽象化し、複雑なLLMワークフローの実装を容易にするため。 |
| 非同期ジョブキュー | Celery, Redis | APIの応答性を損なうことなく、ログ分析などの重い処理をバックグラウンドで実行するため。 |
| インフラ | Docker | 各コンポーネントを環境から分離し、開発・本番環境の差異をなくし、デプロイを容易にするため。 |
| リアルタイム通信 | WebSocket (Socket.IO) | サーバーとクライアント間の双方向通信を実現し、物語の進行をリアルタイムに反映するため。 |

### 3.3. データフロー

1.  **ユーザー登録:** ユーザーはKeyCloakを通じてアカウントを作成する。認証情報はKeyCloakが一元管理する。登録完了後、KeyCloakのユーザーIDがアプリケーションに通知され、PostgreSQLにアプリケーション固有のユーザーデータが作成される。同時に、対応するPlayerノードがNeo4jに作成される。両者は共通のIDで紐付けられる。
2.  **ゲームプレイ:** クライアントからの行動入力がWebSocketを通じてバックエンド(FastAPI)に送信される。リクエストにはKeyCloakが発行したJWTが含まれ、API側で検証される。
3.  **イベント記録:** 行動はまずPostgreSQLのイベントログテーブルに時系列で記録される。
4.  **コンテキスト取得とLLM:** LangChainは、PostgreSQLからキャラクターの基本情報を、Neo4jから現在の状況に関する関係性（場所、近くのNPCなど）を取得し、コンテキストを構築。LLM APIへプロンプトを送信する。
5.  **物語生成と状態更新:** LLMの応答をクライアントに返すと同時に、物語の変化（新しい関係性の発生など）をNeo4jに書き込む。
6.  **NPC管理:** 脚本家AIなどが物語の進行上、新たな登場人物を必要と判断した場合、NPC管理AIに生成を依頼。NPC管理AIはキャラクターシートを作成し、PostgreSQLとNeo4jに新しいNPCのデータを永続化する。
7.  **非同期処理:** ログの集計や分析など、時間のかかる処理はCeleryワーカーによってバックグラウンドで実行される。

### 3.4. データベースの役割分担

* **KeyCloak:**
    * **責務:** 認証と認可。ユーザーID、パスワード、セッション情報など、セキュリティに関わる情報の管理。
    * **格納データ:** ユーザーアカウント情報。
* **PostgreSQL (Source of Truth for Structured Game Data):**
    * **責務:** 構造化されたゲームデータの永続化、トランザクション管理。
    * **格納データ:** KeyCloakのユーザーIDと紐付いたプレイヤープロフィール、全キャラクター（Player, Log, NPC）のステータス・スキル・所持品リスト、全プレイヤーの行動の生ログ。
* **Neo4j (Source of Truth for Relationships):**
    * **責務:** データ間の関係性の表現、コンテキストの高速な検索。
    * **格納データ:** Player, LogNPC, NPCといった世界の構成要素（ノード）と、それらを繋ぐINTERACTED_WITH, LOCATED_INなどの動的な関係（エッジ）。

## 4. プロジェクト計画 (Project Plan)

### 4.1. マイルストーン

* **フェーズ1: 技術検証 (〜1ヶ月)**
    * LLMと各データベースを連携させた基本対話システムのプロトタイプ開発。
    * Dockerによるローカル開発環境の構築。
    * KeyCloakとFastAPIの連携検証。
* **フェーズ2: MVP開発 (〜3ヶ月)**
    * コアサイクル（キャラクター作成、テキストベースの冒険、ログ生成、NPCとしての登場）の実装。
    * 全てのGM AI（脚本家、歴史家、世界の意識、混沌、NPC管理、状態管理）の基本機能を実装。
    * 基本的なUIの実装。
    * 目標: ローカル環境で一通りのシングルプレイ体験が可能になること。
* **フェーズ3: クローズドαテスト (〜1ヶ月)**
    * 目的に集中: 限定的なユーザーへの公開と、それに基づくフィードバック収集、ゲームバランス調整、バグ修正。
* **フェーズ4: オープンβ以降**
    * 目的に集中: コミュニティ機能（フレンド、チャット等のマルチプレイ要素）の実装と、インフラのスケールアウト。

### 4.2. リスクと対策

| リスク | 影響度 | 発生可能性 | 対策 |
| :--- | :--- | :--- | :--- |
| LLMのコスト | 高 | 中 | プロンプトの最適化、安価なモデルの併用、ユーザーあたりのAPIコール数制限。 |
| LLMの応答の質 | 高 | 中 | プロンプトエンジニアリングの徹底、ファインチューニングの検討、不適切な応答のフィルタリング。 |
| 複数AIの協調動作 | 高 | 中 | 各AIの役割と責任範囲を明確に定義。AI間の情報伝達プロトコルを設計し、意図しない相互作用を監視する。 |
| 個人情報の扱い | 高 | 低 | 「ログ」生成時に個人情報を特定・削除するアルゴリズムを導入。利用規約で明記。KeyCloakの導入により、パスワード等の機密情報を自前で管理するリスクを低減。 |
| データベースのパフォーマンス | 中 | 中 | 適切なインデックス設計、クエリの最適化。負荷増大時はサーバーのスケールアップを検討。 |

## 5. 補足資料 (Appendices)

* ゲーム企画概要: \[添付ファイルへのリンク\]
* 技術選定メモ: \[添付ファイルへのリンク\]
* プロンプト設計思想: (別途作成予定)
* UIワイヤーフレーム: (別途作成予定)
