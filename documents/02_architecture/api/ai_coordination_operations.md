# AI協調運用ガイド

**最終更新日:** 2025/06/16  
**親ドキュメント:** [AI協調動作プロトコル仕様書](./ai_coordination_protocol.md)

## 1. エラーハンドリング戦略

### 1.1 タイムアウト処理

**CoordinatorAIクラス - タイムアウト処理実装**

`invoke_agents_with_timeout`メソッド：
- 各AIエージェントを設定されたタイムアウト時間内で呼び出し
- タイムアウト時はデフォルトレスポンスを返却
- エラー時はフォールバックレスポンスを使用
- 全てのエラーとタイムアウトをロギングとメトリクスに記録

`get_timeout_config`メソッド：
- エージェント別のタイムアウト設定を管理
- dramatist: 10秒（物語生成は時間がかかる）
- state_manager: 5秒（ルール判定は高速）
- historian: 8秒（履歴検索に時間がかかる）
- npc_manager: 7秒（NPC処理は中程度）
- world: 6秒（世界イベントは比較的高速）
- anomaly: 4秒（混沌チェックは最速）

### 1.2 フォールバック戦略

**FallbackManagerクラス - エラー時のフォールバック戦略**

エラー発生時に各AIエージェント用の適切なフォールバック応答を生成するクラス。

主要メソッド：
- `get_fallback_response`: エージェント名に基づいて適切なフォールバック戦略を選択
- 各AIエージェント専用のフォールバックメソッド：
  - `dramatist_fallback`: アクションタイプに応じた基本的な定型文を返す
  - `state_manager_fallback`: 戦闘時のみ基本的なダメージ計算（-10HP）を実行
  - `world_fallback`: 世界状態を"stable"として維持
  - `anomaly_fallback`: 混沌イベントなしの応答を返す
  - `historian_fallback`: 記録完了のみを通知
  - `npc_manager_fallback`: NPCカウント0の基本応答
  - `default_fallback`: 未知のエージェント用の汎用フォールバック

全てのフォールバック応答にはmetadataに"fallback: True"が含まれる。

### 1.3 一貫性チェック

**ConsistencyValidatorクラス - レスポンス一貫性検証**

統合されたAIレスポンスの一貫性を検証し、矛盾を解決するクラス。

主要機能：
1. **validate_integrated_response**: 4つの観点から統合レスポンスを検証
   - 状態変更の妥当性
   - 物語の一貫性
   - イベントの妥当性
   - 選択肢の利用可能性

2. **check_state_consistency**: 状態変更の詳細チェック
   - HP値の範囲検証（0以上999以下）
   - レベルの妥当性（1以上100以下）
   - 死亡状態とHPの矛盾チェック

3. **resolve_conflicts**: 検出された矛盾の自動解決
   - HP上限超過 → 999に修正
   - レベル下限違反 → 1に修正
   - 死亡状態の矛盾 → HP=0に修正
   - 解決済みフラグと元のエラー情報をmetadataに記録

## 2. パフォーマンス最適化

### 2.1 キャッシング戦略

**ResponseCacheクラス - AI応答キャッシュ管理**

LRU（Least Recently Used）方式でAI応答をキャッシュするクラス。

主要機能：
- **初期化パラメータ**:
  - ttl: キャッシュの有効期限（デフォルト300秒）
  - max_size: 最大キャッシュサイズ（デフォルト1000エントリ）

- **get_cached_response**: キャッシュからレスポンスを取得
  - TTLチェックを実行し、期限切れエントリは自動削除
  - LRU方式で最近使用したエントリを末尾に移動
  - ヒット/ミスカウントを記録

- **cache_response**: 新しいレスポンスをキャッシュに追加
  - サイズ上限に達した場合は最も古いエントリを削除
  - レスポンスのディープコピーを保存

- **get_hit_rate**: キャッシュヒット率を計算して返す

- **invalidate_pattern**: 指定パターンに一致するエントリを一括削除

### 2.2 バッチ処理最適化

**BatchProcessorクラス - AI呼び出しのバッチ処理最適化**

複数のAI呼び出しリクエストをバッチにまとめて効率的に処理するクラス。

主要機能：
- **初期化パラメータ**:
  - batch_size: バッチサイズ（デフォルト5リクエスト）
  - batch_timeout: バッチタイムアウト（デフォルト0.1秒）

- **add_request**: 新しいリクエストをバッチキューに追加
  - バッチサイズに達したら即座に処理開始
  - サイズに満たない場合はタイムアウト後に処理

- **_process_batch**: バッチ処理の実行
  - 複数のコンテキストを1つにマージ
  - 1回のLLM呼び出しで全リクエストを処理
  - レスポンスを個別に分解してコールバック実行

このアプローチにより、LLM呼び出し回数を削減し、レイテンシとコストを最適化。

### 2.3 優先順位付きキュー

**PriorityEventQueueクラス - 優先順位付きイベントキュー**

ゲームイベントを優先順位、タイムスタンプ、追加順序でソートして管理するクラス。

主要機能：
- **put**: イベントをキューに追加
  - 優先順位値の負数を使用（高優先度が先）
  - タイムスタンプと内部カウンターで安定ソート
  - asyncio.Lockで同期制御

- **get**: 最高優先度のイベントを取得して削除
  - heapqを使用した効率的な優先順位キュー実装
  - 空キューの場合はQueueEmpty例外を発生

- **clear_by_type**: 特定タイプのイベントを一括削除
  - フィルタリング後にheapifyで再構築

- **ユーティリティメソッド**: empty()とsize()でキュー状態を確認

## 3. メトリクスとモニタリング

### 3.1 パフォーマンスメトリクス

**AIPerformanceMetricsクラス - パフォーマンス計測**

AI処理のパフォーマンスデータを収集・分析するクラス。

主要機能：
- **record_response_time**: 各エージェントのレスポンス時間を記録
  - タイムスタンプ付きで保存
  - 1時間以上前のデータは自動削除

- **get_average_response_time**: 指定時間枠内の平均レスポンス時間を計算
  - デフォルトは過去5分間
  - エージェント別に計算

- **get_metrics_summary**: 全体的なメトリクスサマリーを生成
  - エージェント別の平均レスポンス時間、エラー率、タイムアウト率
  - キャッシュのヒット率と統計情報
  - ISO形式のタイムスタンプ付き

保持データ：
- response_times: エージェント別のレスポンス時間履歴
- error_counts: エラー発生回数
- timeout_counts: タイムアウト発生回数
- cache_metrics: キャッシュ統計（ヒット、ミス、エビクション）

### 3.2 ヘルスチェック

**AIHealthCheckerクラス - ヘルスチェック実装**

AIシステム全体の健全性を定期的に監視するクラス。

主要機能：
- **start_health_monitoring**: 60秒間隔で継続的なヘルスチェックを実行

- **check_agent_health**: 個別エージェントの健全性チェック
  - テストコンテキストでの呼び出し
  - 5秒のタイムアウト設定
  - レスポンス時間の計測
  - ステータス: healthy/timeout/error

- **get_system_health**: システム全体のヘルス状態サマリー
  - overall_status: 全エージェントが正常なら"healthy"、それ以外は"degraded"
  - 正常エージェント数と総数
  - 各エージェントの詳細ステータス
  - ISO形式のタイムスタンプ

監視項目：
- エージェントの応答性
- タイムアウトやエラーの発生
- レスポンス時間
- 最終チェック時刻

## 4. テスト戦略

### 4.1 単体テスト

**TestCoordinatorAIクラス - 単体テスト実装**

Coordinator AIの単体テストクラス（pytest使用）。

主要テスト：
1. **フィクスチャ**:
   - `mock_agents`: dramatist、state_manager、worldのモックエージェントを作成
   - `coordinator`: テスト用のCoordinatorAIインスタンスを生成

2. **test_simple_movement_action**: 移動アクションのテスト
   - 移動アクションで必要なAIのみが呼ばれることを確認
   - dramatistは呼ばれ、state_managerは呼ばれないことを検証

3. **test_parallel_execution**: 並列実行性能のテスト
   - 探索アクションの実行時間を計測
   - 並列実行により0.5秒以内に完了することを確認
   - 順次実行の場合より高速であることを検証

### 4.2 統合テスト

**TestAIIntegrationクラス - 統合テスト実装**

AI協調動作の統合テストクラス。

主要テスト：
1. **test_event_chain_reaction**: イベント連鎖反応のテスト
   - 混沌イベント（dimensional_rift）を発生
   - イベント処理後に連鎖イベントが生成されることを確認
   - parent_event_idで親子関係を検証

2. **test_consensus_decision**: コンセンサス決定のテスト
   - 3つの選択肢を持つ決定ポイントを作成
   - 複数AIの評価に基づく決定が行われることを確認
   - 選択された選択肢の妥当性、スコア、評価数を検証

### 4.3 負荷テスト

**LoadTesterクラス - 負荷テスト実装**

AI協調システムの負荷テストを実行するクラス。

**test_concurrent_sessions**: 並行セッションの負荷テスト
- パラメータ:
  - num_sessions: 並行セッション数（デフォルト100）
  - actions_per_session: セッションあたりのアクション数（デフォルト10）

- テスト内容:
  - 各セッションで指定数のランダムアクションを実行
  - 各アクションの実行時間と成功/失敗を記録
  - 1-3秒のランダムな間隔でリアルなペースをシミュレート
  - asyncio.gatherで全セッションを並行実行
  - 結果を集計して分析

このテストにより、システムの並行処理能力とスケーラビリティを検証。

## 5. 今後の拡張計画

### 5.1 機械学習統合

**MLOptimizerクラス - 機械学習による最適化**

機械学習を活用してAI協調を最適化するクラス。

主要機能：
1. **predict_next_actions**: 次のプレイヤーアクションを予測
   - 現在のアクションと履歴から特徴量を抽出
   - 上位5つの予測アクションを返す
   - 各予測にアクションタイプ、確率、必要なエージェントを含む

2. **optimize_agent_selection**: 最適なエージェント選択
   - 過去のパフォーマンスデータに基づいて学習
   - アクションとコンテキストから最適なエージェントセットを予測
   - 必要最小限のエージェントのみを選択してパフォーマンスを向上

この実装により、システムは使用パターンを学習し、時間とともに効率が向上する。

### 5.2 分散処理対応

**DistributedCoordinatorクラス - 分散処理対応**

分散環境でAI協調を実行するクラス。

主要機能：
- **初期化**: クラスター設定、エージェントノード管理、ロードバランサーを初期化

- **distribute_agent_processing**: エージェント処理の分散実行
  - ロードバランサーで最適なノードを選択
  - 30秒のタイムアウトでリモート処理を実行
  - NodeUnavailable例外時は自動的にバックアップノードにフェイルオーバー

この実装により、AIエージェントを複数のノードに分散配置し、高可用性とスケーラビリティを実現。

### 5.3 リアルタイム最適化

**RealtimeOptimizerクラス - リアルタイム最適化**

システム負荷に応じて処理品質を動的に調整するクラス。

品質レベル設定：
- **high**: タイムアウト10秒、temperature 0.8（高品質・低速）
- **medium**: タイムアウト5秒、temperature 0.6（中品質・中速）
- **low**: タイムアウト2秒、temperature 0.4（低品質・高速）

主要機能：
1. **adjust_quality_level**: 負荷に基づく品質レベルの自動調整
   - 負荷80%超: low品質で高速応答を優先
   - 負荷50-80%: medium品質でバランス重視
   - 負荷50%未満: high品質で最高の出力

2. **adaptive_processing**: 適応的な処理の実行
   - 現在の負荷を取得して品質レベルを決定
   - 選択された品質設定で処理を実行
   - 目標応答時間3秒を基準に最適化

## 6. まとめ

本運用ガイドは、AI協調システムの安定的な運用とパフォーマンス最適化のための包括的な指針を提供します。

主要なポイント：
- **堅牢なエラーハンドリング**: タイムアウトとフォールバック戦略
- **パフォーマンス最適化**: キャッシング、バッチ処理、優先順位付け
- **継続的なモニタリング**: メトリクス収集とヘルスチェック
- **包括的なテスト**: 単体、統合、負荷テスト
- **将来への準備**: ML統合、分散処理、リアルタイム最適化

これらの実践により、ゲスタロカのAI協調システムは高い信頼性とスケーラビリティを維持しながら、プレイヤーに優れた体験を提供できます。